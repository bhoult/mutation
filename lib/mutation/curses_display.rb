# frozen_string_literal: true

require 'curses'

module Mutation
  class CursesDisplay
    attr_reader :running, :camera_x, :camera_y

    BOTTOM_PANEL_HEIGHT = 5 # Height of the combined log and status area
    HELP_LINES = 1 # Number of lines for help information
    TOTAL_BOTTOM_LINES = BOTTOM_PANEL_HEIGHT + HELP_LINES

    BORDER_SIZE = 3 # Space for Y-axis labels and top/left border

    def initialize(world, simulator = nil)
      @world = world
      @simulator = simulator
      @running = false
      @camera_x = 0
      @camera_y = 0
      @last_key = nil
      @paused = false
      @last_step_time = Time.now
      @display_fps = 30 # Target display refresh rate (frames per second)
      @frame_count = 0
      @fps_start_time = Time.now
      @log_buffer = [] # Stores multiple unique messages
      @last_logged_message = nil

      # Initialize curses
      Curses.init_screen
      Curses.start_color
      Curses.cbreak
      Curses.noecho
      Curses.curs_set(0) # Hide cursor

      # Try to enable non-blocking input
      $stdin.sync = true

      # Get screen dimensions
      @screen_height = Curses.lines - TOTAL_BOTTOM_LINES # Leave room for status/logs/help
      @screen_width = Curses.cols

      # Adjust screen dimensions for border
      @screen_height -= BORDER_SIZE
      @screen_width -= BORDER_SIZE * 2 # Left and right border

      # Calculate panel widths (accounting for separator)
      @status_panel_width = ((@screen_width - 1) / 4).floor # Half of previous width
      @log_panel_width = @screen_width - @status_panel_width - 1 # -1 for the separator

      # Initialize color pairs
      init_colors

      # Register self as a logger appender
      Mutation.logger.add_appender(self)

      # Calculate viewport
      update_viewport
    end

    def init_colors
      # Define color pairs for different energy levels
      Curses.init_pair(1, Curses::COLOR_GREEN, Curses::COLOR_BLACK)   # High energy (8-10)
      Curses.init_pair(2, Curses::COLOR_YELLOW, Curses::COLOR_BLACK)  # Medium energy (4-7)
      Curses.init_pair(3, Curses::COLOR_RED, Curses::COLOR_BLACK)     # Low energy (1-3)
      Curses.init_pair(4, Curses::COLOR_WHITE, Curses::COLOR_BLACK)   # Empty space
      Curses.init_pair(5, Curses::COLOR_CYAN, Curses::COLOR_BLACK)    # Status bar
      Curses.init_pair(6, Curses::COLOR_MAGENTA, Curses::COLOR_BLACK) # UI elements
    end

    def update_viewport
      world_width = @world.instance_variable_get(:@width)
      world_height = @world.instance_variable_get(:@height)

      # Adjust viewport to fit within the screen dimensions, accounting for border
      @viewport_width = [@screen_width - BORDER_SIZE * 2, world_width].min
      @viewport_height = [@screen_height - BORDER_SIZE, world_height].min

      # Calculate if scrolling is needed
      @needs_scrolling_x = world_width > @viewport_width
      @needs_scrolling_y = world_height > @viewport_height

      # Clamp camera position to valid ranges
      max_camera_x = [world_width - @viewport_width, 0].max
      max_camera_y = [world_height - @viewport_height, 0].max

      @camera_x = [[@camera_x, 0].max, max_camera_x].min
      @camera_y = [[@camera_y, 0].max, max_camera_y].min
    end

    def start
      @running = true

      begin
        display_loop
      ensure
        cleanup
      end
    end

    def stop
      @running = false
    end

    def cleanup
      Curses.close_screen
    end

    def log_message(level, message)
      # Comprehensive regex to strip all ANSI escape codes
      stripped_message = message.gsub(/\e\[(?:\d{1,3}(?:;\d{1,3})*)?[m|K]/, '')

      # Filter out specific status messages (e.g., "T: G: A: | grid")
      # This regex matches the full status line generated by World#status_line
      status_line_pattern = /^T:\s*\d+\s*G:\s*\d+\s*A:\s*\d+\s*\|\s*\d+x\d+\s*grid$/
      return if stripped_message.match?(status_line_pattern)

      formatted_message = "[#{Time.now.strftime('%H:%M:%S')}] #{stripped_message}"
      # Only add if different from the last logged message
      unless formatted_message == @last_logged_message
        @log_buffer << formatted_message
        @log_buffer.shift if @log_buffer.size > BOTTOM_PANEL_HEIGHT # Keep only the last N unique messages
        @last_logged_message = formatted_message
      end
    end

    private

    def display_loop
      frame_time = 1.0 / @display_fps
      
      while @running
        frame_start = Time.now
        
        begin
          # Check for input first (OS buffers keypresses)
          handle_input
          
          # Exit immediately if quit was pressed
          break unless @running

          # Step the simulation based on its own timing
          step_simulation_with_timing

          # Exit immediately if quit was pressed during simulation step
          break unless @running

          # Update display
          draw_world
          draw_bottom_panels
          draw_help
          Curses.refresh

          # Track FPS
          @frame_count += 1

          # Check for terminal resize
          check_terminal_resize

          # Sleep to maintain target FPS
          frame_elapsed = Time.now - frame_start
          sleep_time = frame_time - frame_elapsed
          sleep(sleep_time) if sleep_time > 0
        rescue StandardError => e
          # Log error but continue running unless we're trying to quit
          Mutation.logger.debug("Display error: #{e.message}")
          break unless @running  # Exit if we're quitting, even on error
          sleep(0.01)
        end
      end
    end

    def step_simulation
      return if @paused
      return unless @simulator
      return unless @running # Stop stepping if quit was pressed

      @simulator.step
    end

    def step_simulation_with_timing
      return if @paused
      return unless @simulator
      return unless @running # Stop stepping if quit was pressed

      current_time = Time.now
      simulation_delay = Mutation.configuration.simulation_delay
      
      # Only step if enough time has passed since last step
      if current_time - @last_step_time >= simulation_delay
        @simulator.step
        @last_step_time = current_time
      end
    end

    def calculate_fps
      current_time = Time.now
      elapsed = current_time - @fps_start_time
      
      # Update FPS every second
      if elapsed >= 1.0
        fps = (@frame_count / elapsed).round(1)
        @frame_count = 0
        @fps_start_time = current_time
        @current_fps = fps
      end
      
      @current_fps || 0.0
    end

    def handle_input
      begin
        # Use curses timeout for non-blocking input
        Curses.stdscr.timeout = 0 # Non-blocking
        key = Curses.getch
        input_received = false

        if key && key != -1
          
          input_received = true
          @last_key = begin
            key.chr
          rescue StandardError
            key.to_s
          end

          case key
          when 'q', 'Q'
            @running = false
            @last_key = 'QUIT'
            # Signal the simulator to quit immediately
            @simulator&.request_quit
          when ' ' # Space for pause/resume
            @paused = !@paused
            @last_key = @paused ? 'PAUSED' : 'RESUMED'
            # Force immediate display update to show pause state
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          when 'w', 'W'
            move_camera(0, -1)
            @last_key = 'UP'
            # Force immediate display update to show camera movement
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          when 's', 'S'
            move_camera(0, 1)
            @last_key = 'DOWN'
            # Force immediate display update to show camera movement
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          when 'a', 'A'
            move_camera(-1, 0)
            @last_key = 'LEFT'
            # Force immediate display update to show camera movement
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          when 'd', 'D'
            move_camera(1, 0)
            @last_key = 'RIGHT'
            # Force immediate display update to show camera movement
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          when 'r', 'R'
            @camera_x = 0
            @camera_y = 0
            @last_key = 'RESET VIEW'
            # Force immediate display update to show camera reset
            draw_world
            draw_bottom_panels
            draw_help
            Curses.refresh
          end
        end

        # Auto-quit disabled in visual mode - let user control when to quit
        # Users can press 'q' to quit manually

        input_received
      rescue StandardError => e
        Mutation.logger.error("Error in handle_input: #{e.message}")
        false # Indicate no input was successfully handled
      end
    end

    def move_camera(dx, dy)
      # Get world dimensions through proper accessors
      if @world.respond_to?(:width) && @world.respond_to?(:height)
        world_width = @world.width
        world_height = @world.height
      else
        # Fallback to instance variables if accessors don't exist
        world_width = @world.instance_variable_get(:@width)
        world_height = @world.instance_variable_get(:@height)
      end

      new_x = @camera_x + dx
      new_y = @camera_y + dy

      # Clamp to valid range
      max_camera_x = [world_width - @viewport_width, 0].max
      max_camera_y = [world_height - @viewport_height, 0].max

      @camera_x = [[new_x, 0].max, max_camera_x].min
      @camera_y = [[new_y, 0].max, max_camera_y].min
    end

    def draw_world
      grid = @world.grid
      return unless grid

      # Clear screen first
      Curses.clear

      # Draw top border (X-axis labels)
      Curses.attron(Curses.color_pair(6))
      (0...@viewport_width).each do |i|
        x_coord = @camera_x + i
        if x_coord % 10 == 0
          label = x_coord.to_s
          # Position the label to be centered or left-aligned at the 10s mark
          # Ensure it doesn't overwrite the next label or go off screen
          Curses.setpos(0, BORDER_SIZE + i)
          Curses.addstr(label)
        end
      end

      # Draw left border (Y-axis labels)
      (0...@viewport_height).each do |i|
        y_coord = @camera_y + i
        label = y_coord.to_s.rjust(BORDER_SIZE - 1) # Right-justify label
        Curses.setpos(BORDER_SIZE + i, 0)
        Curses.addstr(label)
      end

      # Draw the world content, shifted by BORDER_SIZE
      (0...@viewport_height).each do |screen_y|
        (0...@viewport_width).each do |screen_x|
          world_x = @camera_x + screen_x
          world_y = @camera_y + screen_y

          # Bounds checking
          next if world_y >= grid.size || world_x >= (grid[world_y]&.size || 0)

          # Get agent at this position
          agent = grid[world_y] && grid[world_y][world_x]

          # Determine character and color based on energy level
          if agent&.alive?
            char, color = agent_display(agent)
          elsif agent
            # Dead agent - show red 'x'
            char = 'x'
            color = 3 # Red for dead
          else
            char = ' '  # Blank space for empty
            color = 4 # White for empty
          end

          # Draw character, shifted by BORDER_SIZE
          Curses.attron(Curses.color_pair(color))
          Curses.setpos(BORDER_SIZE + screen_y, BORDER_SIZE + screen_x)
          Curses.addch(char)
          Curses.attroff(Curses.color_pair(color))
        end
      end

      # Draw right border
      (0...@viewport_height + BORDER_SIZE).each do |i|
        Curses.setpos(i, BORDER_SIZE + @viewport_width)
        Curses.addch('|')
      end

      # Draw bottom border
      Curses.setpos(BORDER_SIZE + @viewport_height, 0)
      Curses.addstr('-' * (@screen_width + BORDER_SIZE * 2))

      Curses.attroff(Curses.color_pair(6))
    end

    def agent_display(agent)
      energy = agent.energy

      # All agents display as '*' character
      char = '*'

      # Choose color based on energy level
      color = case energy
              when 8..Float::INFINITY then 1  # Green for high energy
              when 4..7 then 2                # Yellow for medium energy
              when 1..3 then 3                # Red for low energy
              else 4                          # White for empty
              end

      [char, color]
    end

    def draw_bottom_panels
      bottom_panel_start_y = Curses.lines - TOTAL_BOTTOM_LINES

      # Draw Log Panel (Left)
      draw_log_panel_content(bottom_panel_start_y, 0, @log_panel_width, BOTTOM_PANEL_HEIGHT)

      # Draw Separator
      Curses.attron(Curses.color_pair(6))
      (0...BOTTOM_PANEL_HEIGHT).each do |i|
        Curses.setpos(bottom_panel_start_y + i, @log_panel_width)
        Curses.addch('|')
      end
      Curses.attroff(Curses.color_pair(6))

      # Draw Status Panel (Right)
      draw_status_panel_content(bottom_panel_start_y, @log_panel_width + 1, @status_panel_width, BOTTOM_PANEL_HEIGHT)
    end

    def draw_log_panel_content(start_y, start_x, width, height)
      Curses.attron(Curses.color_pair(5))
      (0...height).each do |i|
        Curses.setpos(start_y + i, start_x)
        Curses.clrtoeol
        log_line = @log_buffer[i] || ''
        truncated_log_line = log_line[0, width - 1]
        Curses.addstr(truncated_log_line)
      end
      Curses.attroff(Curses.color_pair(5))
    rescue StandardError => e
      Mutation.logger.error("Error in draw_log_panel_content: #{e.message}")
    end

    def draw_status_panel_content(start_y, start_x, width, height)
      begin
        Curses.attron(Curses.color_pair(5))

        # Status information
        tick = @world.tick
        generation = @world.generation
        agents = @world.agent_count
        procs = @world.respond_to?(:process_count) ? @world.process_count : 0
        avg_energy = @world.average_energy.round(1)
        fps = calculate_fps

        status_items = [
          "T: #{tick}",
          "G: #{generation}",
          "Agents: #{agents}",
          "Procs: #{procs}",
          "AvgE: #{avg_energy}",
          "FPS: #{fps}"
        ]

        # Add camera info if applicable
        if @needs_scrolling_x || @needs_scrolling_y
          world_width = @world.instance_variable_get(:@width)
          world_height = @world.instance_variable_get(:@height)
          max_camera_x = [world_width - @viewport_width, 0].max
          max_camera_y = [world_height - @viewport_height, 0].max
          status_items << "View:(#{@camera_x},#{@camera_y})/#{max_camera_x},#{max_camera_y}"
        end

        # Add paused indicator
        status_items << '[PAUSED]' if @paused

        # Display status items, one per line
        (0...height).each do |i|
          Curses.setpos(start_y + i, start_x)
          Curses.clrtoeol
          status_text = status_items[i] || ''
          truncated_status_text = status_text[0, width - 1]
          Curses.addstr(truncated_status_text)
        end
        Curses.attroff(Curses.color_pair(5))
      rescue StandardError => e
        Mutation.logger.error("Error in draw_status_panel_content: #{e.message}")
      end
    end

    def draw_help
      help_y = Curses.lines - HELP_LINES

      # Bounds check for help line
      return if help_y >= Curses.lines

      Curses.attron(Curses.color_pair(6))
      Curses.setpos(help_y, 0)
      Curses.clrtoeol # Clear to end of line

      help_text = if @needs_scrolling_x || @needs_scrolling_y
                    'WASD:Scroll | SPACE:Pause | R:Reset View | Q:Quit'
                  else
                    'SPACE:Pause | R:Reset View | Q:Quit'
                  end

      help_text += " | Last:#{@last_key}" if @last_key

      # Truncate to screen width
      max_width = [@screen_width, Curses.cols].min
      help_text = help_text[0, max_width - 1] if help_text.length >= max_width

      Curses.setpos(help_y, 0)
      Curses.addstr(help_text)
      Curses.attroff(Curses.color_pair(6))
    end

    def check_terminal_resize
      new_height = Curses.lines
      new_width = Curses.cols

      # Store current dimensions to compare
      @stored_height ||= new_height
      @stored_width ||= new_width

      return unless new_height != @stored_height || new_width != @stored_width

      # Terminal was resized, update dimensions
      @stored_height = new_height
      @stored_width = new_width
      @screen_height = new_height - 2
      @screen_width = new_width

      # Update viewport calculations
      update_viewport

      # Clear screen to prevent artifacts
      Curses.clear

      # Force a complete redraw
      Curses.refresh
    end

    def paused?
      @paused
    end
  end
end
